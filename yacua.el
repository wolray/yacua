(require 'calc)

(defun yacua-split (txt)
  (let* ((p (length txt))
	 (char (substring txt (1- p) p))
	 pp num)
    (when (string-match-p "[0-9]" char)
      (while (and (> p 0) (string-match-p "[0-9.]" char) (not (eq pp 1)))
	(and (string= char ".") (setq pp (if pp 1 0)))
	(setq p (1- p))
	(and (> p 0) (setq char (substring txt (1- p) p))))
      (setq num (substring txt p)
	    txt (substring txt 0 p))
      (and (> (length num) 0)
	   (string= (substring num 0 1) ".")
	   (setq txt (concat txt ".")
		 num (substring num 1))))
    (cons txt num)))

(defun yacua-insert ()
  (interactive)
  (unless (minibufferp)
    (when (use-region-p)
      (let ((co (current-column))
	    (beg (region-beginning))
	    (end (region-end))
	    (txt (read-string "Insert: "))
	    num inc prc ins)
	(when (> (length txt) 0)
	  (setq txt (yacua-split txt)
		num (cdr txt)
		txt (car txt))
	  (when num
	    (setq inc (read-string "Increment: "))
	    (and (= (string-to-number inc) 0) (setq inc "0"))
	    (setq prc (max (length (cadr (split-string num "\\.")))
			   (length (cadr (split-string inc "\\."))))
		  fmt (concat "%." (number-to-string prc) "f")))
	  (goto-char beg)
	  (save-excursion
	    (while (and (not (eobp))
			(or (= (current-column) co)
			    (and (> (current-column) co) (forward-line) nil)
			    (and (move-to-column co)))
			(<= (point) end))
	      (unless (< (current-column) co)
		(and num (setq num (format fmt (string-to-number num))))
		(setq ins (concat txt num))
		(insert ins)
		(setq end (+ end (length ins)))
		(and num (setq num (calc-eval
				    (concat num "+" inc)))))
	      (forward-line)))
	  (goto-char end))))))

(global-set-key (kbd "H-\\") 'yacua-insert)

(provide 'yacua)
